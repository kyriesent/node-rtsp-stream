// Generated by CoffeeScript 2.3.2
(function() {
  var Mpeg1Muxer, STREAM_MAGIC_BYTES, VideoStream, events, util, ws;

  ws = require('ws');

  util = require('util');

  events = require('events');

  Mpeg1Muxer = require('./mpeg1muxer');

  STREAM_MAGIC_BYTES = "jsmp"; // Must be 4 bytes

  VideoStream = function(options) {
    this.options = options;
    this.name = options.name;
    this.streamUrl = options.streamUrl;
    this.width = options.width;
    this.height = options.height;
    this.wsPort = options.wsPort;
    this.inputStreamStarted = false;
    this.stream = void 0;
    this.startMpeg1Stream();
    this.pipeStreamToSocketServer();
    return this;
  };

  util.inherits(VideoStream, events.EventEmitter);

  VideoStream.prototype.stop = function() {
    this.wsServer.close();
    this.stream.kill();
    this.inputStreamStarted = false;
    return this;
  };

  VideoStream.prototype.startMpeg1Stream = function() {
    var gettingInputData, gettingOutputData, inputData, outputData, self;
    this.mpeg1Muxer = new Mpeg1Muxer({
      ffmpegOptions: this.options.ffmpegOptions,
      url: this.streamUrl
    });
    this.stream = this.mpeg1Muxer.stream;
    self = this;
    if (this.inputStreamStarted) {
      return;
    }
    this.mpeg1Muxer.on('mpeg1data', function(data) {
      return self.emit('camdata', data);
    });
    gettingInputData = false;
    inputData = [];
    gettingOutputData = false;
    outputData = [];
    this.mpeg1Muxer.on('ffmpegError', function(data) {
      var size;
      data = data.toString();
      if (data.indexOf('Input #') !== -1) {
        gettingInputData = true;
      }
      if (data.indexOf('Output #') !== -1) {
        gettingInputData = false;
        gettingOutputData = true;
      }
      if (data.indexOf('frame') === 0) {
        gettingOutputData = false;
      }
      if (gettingInputData) {
        inputData.push(data.toString());
        size = data.match(/\d+x\d+/);
        if (size != null) {
          size = size[0].split('x');
          if (self.width == null) {
            self.width = parseInt(size[0], 10);
          }
          if (self.height == null) {
            return self.height = parseInt(size[1], 10);
          }
        }
      }
    });
    this.mpeg1Muxer.on('ffmpegError', function(data) {
      return global.process.stderr.write(data);
    });
    return this;
  };

  VideoStream.prototype.pipeStreamToSocketServer = function() {
    var self;
    self = this;
    this.wsServer = new ws.Server({
      port: this.wsPort
    });
    this.wsServer.on("connection", function(socket) {
      return self.onSocketConnect(socket);
    });
    this.wsServer.broadcast = function(data, opts) {
      var i, results;
      results = [];
      for (i in this.clients) {
        if (this.clients[i].readyState === 1) {
          results.push(this.clients[i].send(data, opts));
        } else {
          results.push(console.log("Error: Client (" + i + ") not connected."));
        }
      }
      return results;
    };
    return this.on('camdata', function(data) {
      return self.wsServer.broadcast(data);
    });
  };

  VideoStream.prototype.onSocketConnect = function(socket) {
    var self, streamHeader;
    // Send magic bytes and video size to the newly connected socket
    // struct { char magic[4]; unsigned short width, height;}
    self = this;
    streamHeader = new Buffer(8);
    streamHeader.write(STREAM_MAGIC_BYTES);
    streamHeader.writeUInt16BE(this.width, 4);
    streamHeader.writeUInt16BE(this.height, 6);
    socket.send(streamHeader, {
      binary: true
    });
    console.log(`${this.name}: New WebSocket Connection (` + this.wsServer.clients.length + " total)");
    return socket.on("close", function(code, message) {
      return console.log(`${this.name}: Disconnected WebSocket (` + self.wsServer.clients.length + " total)");
    });
  };

  module.exports = VideoStream;

}).call(this);
